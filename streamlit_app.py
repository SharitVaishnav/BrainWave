# -*- coding: utf-8 -*-
"""NLP_FINAL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qn5r3ihmNXDpLTX0EiiIjaqb8DdBu9AA
"""

# !pip install youtube_transcript_api

# !pip install streamlit pyngrok
# !pkill ngrok
# !pip install reportlab

# !apt-get update
# !apt-get install -y texlive

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import google.generativeai as genai
# import os
# import subprocess
# from urllib.parse import urlparse, parse_qs
# from youtube_transcript_api import YouTubeTranscriptApi, NoTranscriptFound, TranscriptsDisabled
# 
# # Configure the Google Gemini API key securely
# api_key = "AIzaSyALzS_tDmlqMx16097G4Rzv3tq_nMsbmVA"  # Replace with your API key
# genai.configure(api_key=api_key)
# 
# # Define helper functions for YouTube URL processing
# def extract_youtube_id(url):
#     # Parse the URL
#     parsed_url = urlparse(url)
# 
#     # For standard YouTube URLs like 'https://www.youtube.com/watch?v=VIDEO_ID'
#     if parsed_url.hostname in ["www.youtube.com", "youtube.com"]:
#         return parse_qs(parsed_url.query).get("v", [None])[0]
# 
#     # For shortened YouTube URLs like 'https://youtu.be/VIDEO_ID'
#     elif parsed_url.hostname == "youtu.be":
#         return parsed_url.path[1:]  # Remove the leading '/'
# 
#     return None  # Return None if the URL does not match any known YouTube pattern
# 
# # Function to fetch transcript from YouTube using YouTubeTranscriptApi
# def fetch_transcript(video_id):
#     try:
#         # Try to get the manual transcript
#         transcript = YouTubeTranscriptApi.get_transcript(video_id)
#         return transcript, "Manual transcript found."
#     except NoTranscriptFound:
#         try:
#             # Try to fetch autogenerated captions in English (or any preferred language)
#             transcript = YouTubeTranscriptApi.get_transcript(video_id, languages=['hi'])
#             return transcript, "Autogenerated transcript found."
#         except (NoTranscriptFound, TranscriptsDisabled) as e:
#             return None, f"Transcript not available: {e}"
# 
# # Function for answer evaluation using Google Gemini
# def evaluation(ans, question):
#     try:
#         model = genai.GenerativeModel()
#         response = model.generate_content(
#             contents=[ans + " This is the answer to " + question + " now evaluate it in 1-2 lines, and don't repeat this question again."]
#         )
#         if response:
#             return response.text
#         else:
#             return "Evaluation failed. No response from API."
#     except Exception as e:
#         return f"Error during evaluation: {e}"
# 
# # Function to generate LaTeX content
# def generate_latex_content(text_output, prompt):
#     """Generate LaTeX code using Google Gemini API"""
#     try:
#         model = genai.GenerativeModel()
#         response = model.generate_content(
#             contents=[text_output + prompt]
#         )
#         return response.text if response else "Content generation failed."
#     except Exception as e:
#         return f"Error during content generation: {e}"
# 
# # Function to create PDF from LaTeX code
# def create_pdf_from_latex(latex_code):
#     """Save LaTeX code to a .tex file, compile it to PDF, and return the PDF data if successful."""
#     # Save LaTeX code to a .tex file
#     with open("question_paper.tex", "w") as f:
#         f.write(latex_code)
# 
#     # Compile the .tex file to a PDF using pdflatex
#     try:
#         result = subprocess.run(
#             ["pdflatex", "-interaction=nonstopmode", "question_paper.tex"],
#             stdout=subprocess.PIPE,
#             stderr=subprocess.PIPE
#         )
# 
#         if result.returncode != 0:
#             # Display the LaTeX error output if compilation fails
#             st.error("LaTeX compilation failed:")
#             st.text(result.stdout.decode("utf-8"))
#             st.text(result.stderr.decode("utf-8"))
#             return None
# 
#         # Read and return the PDF file data
#         with open("question_paper.pdf", "rb") as f:
#             pdf_data = f.read()
#         return pdf_data
# 
#     except FileNotFoundError:
#         st.error("pdflatex not found. Please ensure it is installed in your environment.")
#         return None
# 
# # Streamlit interface
# st.title("NLP Project using Gemini API")
# 
# # Sidebar options
# st.sidebar.title("Options")
# 
# # User input for YouTube URL
# youtube_url = st.sidebar.text_input("Enter YouTube Video URL")
# 
# # Initialize the text_output (transcript)
# text_output = ""
# 
# # If a YouTube URL is entered
# if youtube_url:
#     video_id = extract_youtube_id(youtube_url)
#     if video_id:
#         # Fetch transcript based on the extracted video ID
#         transcript, message = fetch_transcript(video_id)
#         if transcript:
#             text_output = "\n".join([entry['text'] for entry in transcript])
#             st.sidebar.write(message)
#             st.sidebar.write(f"Transcript from YouTube video ID {video_id} loaded successfully.")
#         else:
#             st.sidebar.error(message)
#     else:
#         st.sidebar.error("Invalid YouTube URL. Please enter a valid URL.")
# 
# # Sidebar options for content generation
# options = [
#     "Summary",
#     "Generate MCQ",
#     "Generate Short Answer Question",
#     "Generate Long Answer Question",
#     "Generate Question Paper",
#     "Other",
# ]
# choice = st.sidebar.selectbox("Select an Option", options)
# 
# # Prompt Selection
# prompts = {
#     "Summary": "Summarise",
#     "Generate MCQ": "Create an MCQ type test on the basis of the given text in a perfect mcq format.",
#     "Generate Short Answer Question": "Create only one any random short answer type question on the basis of the given text and don't give answers",
#     "Generate Long Answer Question": "Create only one any random long answer type question on the basis of the given text and don't give answers",
#     "Generate Question Paper": "You are an educator. Generate the question paper with some MCQ and some long answer and some short answer question and total marks should equal to thr 50 in LaTeX format based on the text provided, and add the name of the institute Indian Institute Of Information Technology, Nagpur at the beginning"
# }
# 
# # Additional input for "Other" option
# if choice == "Other":
#     custom_prompt = st.text_input("Enter Custom Prompt")
# else:
#     custom_prompt = prompts[choice]
# 
# if st.sidebar.button("Generate"):
#     if text_output:
#         prev_ques = []
#         if choice == "Generate Question Paper":
#             # Generate LaTeX question paper code
#             latex_code = generate_latex_content(text_output, custom_prompt)
# 
#             if "Content generation failed." not in latex_code and "Error" not in latex_code:
#                 # Generate PDF from the LaTeX code
#                 pdf_data = create_pdf_from_latex(latex_code)
# 
#                 if pdf_data is not None:
#                     # Provide a download button for the PDF only if pdf_data is valid
#                     st.download_button(
#                         label="Download Question Paper as PDF",
#                         data=pdf_data,
#                         file_name="question_paper.pdf",
#                         mime="application/pdf"
#                     )
#                 else:
#                     st.error("PDF generation failed. Please check the LaTeX code for errors.")
#             else:
#                 st.error("Failed to generate LaTeX content.")
#         elif(choice == "Generate Long Answer Question" or choice == "Generate Short Answer Question"):
#            # Generate question based on the choice
#             generated_question = generate_latex_content(text_output, custom_prompt)
#             st.write("**Generated Question:**")
#             st.write(generated_question)
# 
#             # Get user answer input
#             user_answer = st.text_area("Enter your answer for evaluation:")
#             evaluation_result = evaluation(user_answer, generated_question)
# 
#             # Evaluate only when there's an answer provided
#             if st.button("Evaluate Answer") and user_answer:
#                 try:
#                     # Check if evaluation returned content
#                     if evaluation_result:
#                         st.write("**Evaluation Result:**")
#                         st.write(evaluation_result)
#                     else:
#                         st.write("Evaluation failed. No response from API.")
# 
#                 except Exception as e:
#                     st.write("Error during evaluation:", str(e))
# 
#         else:
#             # Generate summary, MCQ, or short/long answer questions based on choice
#             response_text = generate_latex_content(text_output, custom_prompt)
#             st.write("**Generated Content:**")
#             st.write(response_text)
#     else:
#         st.warning("Please enter the YouTube URL to proceed.")
#

# Start the Cloudflare tunnel to expose the Streamlit app
from pyngrok import ngrok
import os

ngrok.set_auth_token("2ooQkpdG64l6idd8S2p4XvvmSNo_7e2VQprfc984F6YdwkQpM")


# Open a tunnel to the streamlit port 8501
public_url = ngrok.connect(8501)
public_url

!streamlit run app.py

!jupyter nbconvert --to script NLP_FINAL.ipynb

